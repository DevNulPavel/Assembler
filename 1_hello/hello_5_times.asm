%include "stud_io.inc"

; Точка входа в приложение, экспортируем ее, аналог extern
global	_start


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Описываем секцию с неинициализированными данными приложения, указывая только их размер,
; размер нашего исполняемого файлика никак не меняется, так как это данные на стеке
section	.bss

; Резервируем 20 байт
string1:
	resb 20

; Резервируем 20*2 байт (слов)
string2:
	resw 20

; Резервируем 20*4 байт (двойных слов)
string3:
	resd 20

; Резервируем 1*4 байт (двойных слов) для использования в коде для счетчика оперативной памяти
count1:
	resd 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Описываем секцию с фиксированнными данными,
; размер нашего исполняемого файлика увеличивается, так как это область статических данных
section	.data

; Резервируем 8 байт с конкретными значениями
values1:
	db 1,2,3,4,5,6,7,8

; Резервируем 8 слов с конкретными значениями
values2:
	dw 1,2,3,4,5,6,7,8

; Резервируем 8 двойных слов с конкретными значениями
values3:
	dw 0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8

; Резервируем сразу строку из байт c переносом строки в конце
message1:
	db "This is text string",10

; Резервируем сразу строку из байт c переносом строки в конце
message2:
	db "This is text string"

; Резервируем 1*4 байт (двойных слов) для использования в коде для счетчика оперативной памяти
; Значение 0 по-умолчанию
count2:
	dd 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Описываем секцию с кодом приложения, данные в данной секции являются неизменяемыми
; 
section	.text

; Ставим метку
_start:	
	; Записываем в eax 0
	mov	eax, 0
	; Записываем в память count значение eax, квадратные скобки значат разыменование, * в C
	mov [count1], eax
	; Записываем в edx значение адреса count, метка - это просто адрес в памяти
	mov edx, count1
	; Затем с помощью косвенной адресации записываем в ecx то, что у нас по адресу в регистре edx, то есть 0
	mov ecx, [edx]
	; Тип надо указывать для того, чтобы мы понимали какого объема данные записываются в память если не понятно по данным
	; типы - byte, word, dword
	; тип можно указывать как вначале, так и в конце
	mov byte [count1], 10
	mov [count1], byte 10
	; Записываем в память в нулевым смещением 4 байта (двойное слово) из eax
	mov dword [count2+0+0*2], eax
	; При работе с память мы можем использовать два смещения, первое из регистра, второе из регистра умноженного на [0, 1, 2, 4, 8]
	mov eax, 0
	mov ebx, 0
	mov ecx, 12
	mov byte [count2+eax+ebx*2], cl
	mov byte [count2+eax+1], ch

	; Сложение
	add [count1], byte 1
	add [count1], eax
	add [count1], ecx

	; Пример сложения 64х битного числа с учетом флага переноса
	; Число 1, младшая и старшая часть
	mov eax, dword 0
	mov ebx, dword 0
	; Число 2, младшая и старшая часть
	mov ecx, dword 10
	mov edx, dword 10	
	; Складываем младшие части, заполняя флаг переноса CF
	add eax, ecx
	; Складываем старшие части, учитывая флаг переноса
	adc ebx, edx

; Обнуляем регистры процессора
zero_registers:
	xor eax, eax
	xor ebx, ebx
	xor ecx, ecx
	xor edx, edx

again:
	; С помощью макроса выводим текст
    PRINT "Hello"
	; С помощью макроса выводим перенос строки
	PUTCHAR	10
	; Увеличиваем на 1 наш счетчик
	inc	eax
	; Сравниваем значение счетчика, результат пишется в регистр флагов
	cmp	eax, dword 5
	; Сравниваем значение в регистре флагов, если выставлен флаг меньше - переходим
	jl again
	; Иначе завершаем наше приложение
	FINISH
